# Миграция из YouGile в Redmine: конспект

## 1. Общий выбор подхода

- **Источник (YouGile)**
  - К БД/моделям YouGile можно обращаться **только на чтение**.
  - Допустим как прямой SQL, так и доступ через ORM/модели.

- **Приёмник (Redmine)**
  - **Не рекомендуется** писать напрямую в БД Redmine (сложная схема, валидации, коллбеки, история изменений, плагины).
  - Предпочтительные варианты:
    - **REST API Redmine** (через Python, используя готовые библиотеки типа `python-redmine`).
    - **Ruby‑скрипты внутри Redmine** через модели Rails (для специфических сущностей плагинов, если их нет в API).

Вывод: для обычных проектов/задач/комментариев/кастомных полей объёма ~2000 задач и ~1600 комментариев более чем достаточно REST API Redmine. Для плагинов (спринты и т.п.) — гибридный подход.

---

## 2. Что мигрируем

Базовый список сущностей:

- **Проекты** (YouGile Projects → `Project` в Redmine).
- **Пользователи** (match по email → `User` в Redmine).
- **Задачи** (YouGile Tasks → `Issue`).
- **Комментарии** (YouGile Comments → `Journal`/`notes` у задач).
- **Статусы, приоритеты, трекеры** (через маппинг значений).
- **Кастомные поля** (YouGile‑специфика → `custom_fields` Redmine).
- **Файлы/вложения** (опционально → `Attachment`).
- **Плагиновые сущности (спринты, agile‑борды и т.п.)** — отдельно, см. ниже.

---

## 3. Почему не писать в БД Redmine напрямую

- **Сложная схема данных**:
  - Задачи (`issues`), история изменений (`journals`, `journal_details`), кастомные значения (`custom_values`), связи задач, вложения и т.п.
- **Бизнес‑логика в моделях**:
  - Валидации, коллбеки, автоматическое обновление полей, истории, индексов.
- **Плагины** расширяют схему и ожидают, что данные создаются через их модели/контроллеры.
- **Обновления Redmine** могут легко сломать кастомные SQL‑скрипты.

Риск прямой записи SQL — неконсистентные данные и поломанный UI/отчёты/плагины. При таком объёме выгоды от прямого SQL нет, а риск есть.

---

## 4. Подходы к записи в Redmine

### 4.1. REST API Redmine

**Плюсы:**

- Срабатывают все валидации, коллбеки, история изменений.
- Независимость от внутренней схемы БД.
- Можно писать миграционный код на Python (удобно, т.к. уже есть проект вокруг YouGile).

**Минусы:**

- Медленнее, чем прямой SQL (HTTP‑запросы).
- Нужна обработка ошибок/ретраев/лимитов.

### 4.2. Ruby‑скрипты через модели Redmine

- Запуск через `rails runner` или rake‑таски внутри Redmine.
- Работают напрямую с моделями (`Project`, `Issue`, `User`, модели плагинов и т.д.), но **не через HTTP**.

**Плюсы:**

- Быстрее, чем REST (нет HTTP‑оверхода, всё внутри Rails).
- Используются те же валидации/коллбеки/логика, что и у REST, но с полным доступом к любым моделям.

**Минусы:**

- Нужно писать Ruby‑код в репозитории Redmine.
- Сложнее интегрировать с уже существующим Python‑окружением, если делать всё только через Ruby.

**Рекомендуемый гибрид:**

- Для ядра (проекты, задачи, пользователи, комментарии, кастомные поля) — **REST API из Python**.
- Для сущностей плагинов, которых нет в API — **узкие Ruby‑скрипты**, которые читают подготовленные данные (JSON/таблица) и создают/обновляют модели плагинов.

---

## 5. Архитектура решения (Python‑сервис как центр миграции)

Отдельный Python‑сервис (существующий проект, условно `yougile-mcp`) становится "шлюзом" YouGile → Redmine.

### 5.1. Основные модули

- **Модуль клиента YouGile**
  - Читает из БД/ORM YouGile.
  - Умеет получать:
    - проекты,
    - доски/колонки,
    - задачи,
    - комментарии,
    - пользователей,
    - изменения за период (`updated_since`).

- **Модуль клиента Redmine**
  - Обёртка над REST API Redmine, например, через `python-redmine` (`redminelib`).
  - Высокоуровневые методы: `create_project`, `create_or_update_issue`, `add_comment`, `find_or_create_user`, и т.п.

- **Модуль маппинга** (YouGile → Redmine)
  - Описывает соответствие полей:
    - статусы,
    - типы задач/трекеры,
    - приоритеты,
    - пользователи,
    - соответствие колонок/досок YouGile статусам/спринтам/кастомным полям Redmine.

- **Служебное хранилище (своя БД)**
  - Таблицы вида:
    - `yougile_project_id → redmine_project_id`;
    - `yougile_task_id → redmine_issue_id`;
    - `yougile_user_id → redmine_user_id` (если нужно);
    - логи синхронизации, `last_synced_at`.
  - Можно использовать SQLite/PostgreSQL — по ситуации.

- **CLI‑команды**
  - `initial_import` — разовый начальный импорт истории.
  - `sync_once --since ...` — разовый догон изменений за период.
  - `sync_loop` / `webhook_worker` — обработка событий в фоне (при использовании вебхуков).

### 5.2. Роль Redmine‑репозитория (`redmine6_pack`)

- По умолчанию **не трогаем** код Redmine.
- При необходимости добавляем **минимальные Ruby‑таски/скрипты**:
  - для работы с моделями плагинов (спринты, agile‑борды и т.п.), если эти сущности не доступны через REST API и не представлены кастомными полями.

---

## 6. Стратегии миграции и синхронизации

### 6.1. Разовый переезд (миграция в одно окно)

Подходит, если можно организовать окно, когда пользователи не вносят изменения в YouGile.

1. **Первичный большой импорт**
   - Импортируем всю необходимую историю (проекты, задачи, комментарии и т.д.).
2. **В день переезда**
   - Останавливаем работу в YouGile (или договариваемся не трогать систему).
   - Запускаем финальный `sync_once` за последние N часов/дней.
   - Проверяем выборочно данные в Redmine.
   - После этого **YouGile только read‑only** или выключаем.

Плюсы: архитектурно проще, не нужно городить долгоживущую синхронизацию.

### 6.2. Параллельная жизнь (YouGile + Redmine одновременно)

Если нужно, чтобы некоторое время обе системы жили параллельно, есть два подварианта.

#### 6.2.1. Событийная синхронизация (webhook‑based)

1. **Приёмник вебхуков (Python‑сервис)**
   - HTTP‑endpoint, куда YouGile шлёт события: `task-created`, `task-updated`, `comment-created` и т.п.
   - Каждое событие пишем в **очередь** (таблица `events` со статусом `pending/processed/failed`).

2. **Воркер синхронизации**
   - Читает из очереди;
   - По `yougile_task_id` находит или создаёт `redmine_issue_id` через API;
   - Применяет изменения (обновление полей, добавление комментария и т.п.);
   - Помечает событие как `processed` или `failed` (с логом ошибки и, возможно, ретраями).

3. **Периодический reconciliation**
   - Крон‑задача (например, раз в час/ночь):
     - берёт из YouGile все задачи/комментарии с `updated_at > last_reconcile_time`;
     - сверяет с Redmine и досинхронизирует пропущенное (на случай потери вебхуков).

#### 6.2.2. Периодический "пуллинг" (без вебхуков)

- Раз в N минут/часов:
  - читаем из YouGile всё, что изменилось после `last_sync_time`;
  - прогоняем через тот же модуль маппинга и Redmine‑клиент.

Проще, чем вебхуки, но чуть тяжелее по нагрузке на БД YouGile.

---

## 7. Плагины и спринты

### 7.1. Что есть в стандартном REST API

Через стандартное REST API доступны:

- проекты,
- задачи (issues),
- пользователи,
- статусы, трекеры, приоритеты,
- кастомные поля,
- time entries, версии (versions) и т.п.

Если "спринты" реализованы как **кастомные поля** задач/проектов или как `versions`, их можно обслужить полностью через стандартное API.

### 7.2. Плагины (Agile/Scrum и прочие)

- Плагины **не обязаны** иметь REST API.
- Сущности вроде `Sprint`, `Board` и т.п. часто живут в своих таблицах (`sprints`, `scrum_sprints`, и пр.) и доступны только через модели плагина.

Подход:

1. Максимум информации переносим в **стандартные сущности и кастомные поля** (через REST):
   - текущий спринт,
   - story points,
   - типы работ и т.п.

2. Для специфичных сущностей плагинов (если важно их сохранить как отдельные объекты):
   - либо используем API самого плагина (если он его предоставляет),
   - либо пишем **Ruby‑таску/скрипт**, которая:
     - читает подготовленные данные (например, JSON, который выгрузил Python‑сервис);
     - создаёт/обновляет спринты/борды через модели плагина;
     - привязывает задачи (по служебному полю, например `yougile_task_id` в кастомном поле Redmine).

---

## 8. Использование REST API Redmine из Python (конспект по wiki)

См. официальную wiki Redmine: [Using the REST API with Python](https://www.redmine.org/projects/redmine/wiki/Rest_api_with_python).

Основные варианты клиентов:

### 8.1. Python-Redmine (`redminelib`)

- Библиотека с поддержкой **100% возможностей REST API Redmine**.
- Pythonic‑API, похожий на Django ORM.
- Умеет работать со всеми основными ресурсами: проекты, задачи, пользователи, time entries и т.п.

Пример (по wiki, упрощённо):

```python
from redminelib import Redmine

redmine = Redmine('http://demo.redmine.org', username='foo', password='bar')
project = redmine.project.get('vacation')

# Доступ к задачам проекта
for issue in project.issues:
    print(issue.id, issue.subject, issue.status.name)
```

Для миграции удобно инкапсулировать работу с `redminelib` в своём модуле `redmine_client`, чтобы вся логика маппинга была в одном месте.

### 8.2. PyRedmineWS

- Альтернативная библиотека для работы с Redmine.
- В wiki приведён пример изменения сроков задач для конкретного пользователя.
- В контексте миграции достаточно знать, что это альтернатива, но **основной кандидат — Python-Redmine**.

### 8.3. PyActiveResource

- Более низкоуровневый вариант, повторяющий подход ActiveResource (Ruby on Rails).
- Тоже позволяет получать/обновлять задачи через REST, но требует больше ручной работы.

**Общий вывод:** для современного Python‑кода под миграцию удобнее всего использовать **`python-redmine` (`redminelib`)**.

---

## 9. Рекомендуемая общая схема действия

1. **Определить объём и состав миграции**
   - Какие проекты тащим.
   - Только активные задачи или всю историю.
   - Нужны ли вложения.
   - Какие поля из YouGile должны отразиться в Redmine (кастомные поля и т.п.).

2. **Поднять тестовый Redmine** (копию боевой БД или отдельный инстанс).

3. **Реализовать в Python‑сервисе:**
   - клиент YouGile;
   - клиент Redmine (через `python-redmine`);
   - маппинг сущностей;
   - служебную БД для ID‑соответствий;
   - CLI‑команду `initial_import` для одного выбранного проекта.

4. **Прогнать прототип миграции одного проекта на тестовом Redmine**
   - Проверить отображение задач, комментариев, пользователей, статусов.
   - При необходимости подправить маппинг.

5. **Расширить миграцию на все нужные проекты**
   - Запустить полный `initial_import`.

6. **Выбрать стратегию финального переезда**
   - Либо одноразовый догон изменений + отключение YouGile.
   - Либо реализация вебхуков/пуллинга для постепенной синхронизации.

7. **При необходимости — добавить Ruby‑таски в Redmine для плагиновых сущностей**
   - Только тогда, когда станет ясно, какие именно данные плагина принципиально важно перенести как отдельные сущности, а не как поля задач.

---

Этот файл задуман как конспект/памятка для дальнейшей работы в Python‑проекте по миграции из YouGile в Redmine, чтобы не начинать обсуждение с нуля и иметь под рукой общую архитектуру и ключевые решения.
